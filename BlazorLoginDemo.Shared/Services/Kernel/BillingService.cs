// File: Shared/Services/Kernel/BillingService.cs
using System.Linq.Expressions;
using BlazorLoginDemo.Shared.Data;
using BlazorLoginDemo.Shared.Models.Kernel.Billing;
using BlazorLoginDemo.Shared.Models.Static.SysVar;
using BlazorLoginDemo.Shared.Services.Interfaces.Kernel;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using NanoidDotNet;

namespace BlazorLoginDemo.Shared.Services.Kernel;

internal sealed class BillingService : IBillingService
{
    private readonly ApplicationDbContext _db;
    private readonly ILogger<BillingService> _log;
    private readonly ILoggerService _logger;

    public BillingService(ApplicationDbContext db, ILogger<BillingService> log, ILoggerService logger)
    {
        _db  = db;
        _log = log;
        _logger = logger;
    }


    // --------------- CREATE / UPSERT ---------------

    public async Task<Discount> CreateDiscountAsync(IBillingService.CreateDiscountRequest req, CancellationToken ct = default)
    {
        GuardCreate(req);

        var code = string.IsNullOrWhiteSpace(req.DiscountCode)
            ? CodeGen.NewDiscountCode()
            : NormalizeCode(req.DiscountCode!);
        await _logger.InformationAsync(
            evt: "DISCOUNT_CREATE",
            cat: SysLogCatType.Data,
            act: SysLogActionType.Create,
            message: $"Creating Discount '{code}' for Org '{req.ParentOrgId}'",
            ent: nameof(Discount),
            entId: code,
            org: req.ParentOrgId);

        // ensure uniqueness of human-facing code per-tenant (or global)
        var codeExists = await _db.Discounts
            .AsNoTracking()
            .AnyAsync(d => d.DiscountCode == code && d.ParentOrgId == req.ParentOrgId, ct);
        if (codeExists)
        {
            await _logger.WarningAsync(
                evt: "DISCOUNT_CODE_EXISTS",
                cat: SysLogCatType.Data,
                act: SysLogActionType.Validate,
                message: $"Discount code '{code}' already exists. Generating a new one.",
                ent: nameof(Discount),
                entId: code,
                note: "duplicate_code");
            for (int attempt = 0; attempt < 5; attempt++)
            {
                code = CodeGen.NewDiscountCode();
                var exists = await _db.Discounts
                    .AsNoTracking()
                    .AnyAsync(d => d.DiscountCode == code && d.ParentOrgId == req.ParentOrgId, ct);
                if (!exists) break;
            }
        }

        var model = new Discount
        {
            // Id generated by entity
            ParentOrgId = req.ParentOrgId,
            DiscountCode = code,
            DisplayName = req.DisplayName.Trim(),
            Type = req.Type,
            Amount = DecimalNormalize(req.Amount),
            Currency = req.Currency?.Trim().ToUpperInvariant(),
            Scope = req.Scope,
            DurationInPeriods = req.DurationInPeriods,
            StartsAtUtc = req.StartsAtUtc?.ToUniversalTime(),
            EndsAtUtc = req.EndsAtUtc?.ToUniversalTime(),
            SeatMin = req.SeatMin,
            SeatMax = req.SeatMax,
            IsEnabled = req.IsEnabled,
            Notes = req.Notes
        };

        model.Validate(); // model-level guards

        _db.Discounts.Add(model);
        await _db.SaveChangesAsync(ct);
        return model;
    }

    public async Task<IBillingService.CreateDiscountResult> CreateDiscountSimpleAsync(IBillingService.CreateDiscountRequest req, CancellationToken ct = default)
    {
        try
        {
            var d = await CreateDiscountAsync(req, ct);
            _log.LogInformation("Created Discount {Id} ({Name})", d.Id, d.DisplayName);
            return new(true, null, d.Id);
        }
        catch (Exception ex)
        {
            _log.LogError(ex, "CreateDiscount failed");
            return new(false, ex.GetBaseException().Message, null);
        }
    }

    public async Task<Discount> UpsertDiscountByCodeAsync(string code, IBillingService.CreateDiscountRequest req, CancellationToken ct = default)
    {
        var norm = NormalizeCode(code);
        var existing = await _db.Discounts.FirstOrDefaultAsync(d =>
            d.DiscountCode == norm && d.ParentOrgId == req.ParentOrgId, ct);

        if (existing is null)
        {
            // create with provided code
            var createReq = req with { DiscountCode = norm };
            return await CreateDiscountAsync(createReq, ct);
        }

        // update scalar fields only
        existing.DisplayName       = req.DisplayName.Trim();
        existing.Type              = req.Type;
        existing.Amount            = DecimalNormalize(req.Amount);
        existing.Currency          = req.Currency?.Trim().ToUpperInvariant();
        existing.Scope             = req.Scope;
        existing.DurationInPeriods = req.DurationInPeriods;
        existing.StartsAtUtc       = req.StartsAtUtc?.ToUniversalTime();
        existing.EndsAtUtc         = req.EndsAtUtc?.ToUniversalTime();
        existing.SeatMin           = req.SeatMin;
        existing.SeatMax           = req.SeatMax;
        existing.IsEnabled         = req.IsEnabled;
        existing.Notes             = req.Notes;

        existing.Validate();

        await _db.SaveChangesAsync(ct);
        return existing;
    }


    // ------------------- READ ----------------------

    public async Task<Discount?> GetDiscountByIdAsync(string id, CancellationToken ct = default)
        => await _db.Discounts.AsNoTracking().FirstOrDefaultAsync(d => d.Id == id, ct);

    public async Task<Discount?> GetDiscountByCodeAsync(string code, CancellationToken ct = default)
    {
        var norm = NormalizeCode(code);
        return await _db.Discounts.AsNoTracking().FirstOrDefaultAsync(d => d.DiscountCode == norm, ct);
    }

    public async Task<IReadOnlyList<Discount>> SearchDiscountsAsync(IBillingService.DiscountSearchParams f, CancellationToken ct = default)
    {
        var q = _db.Discounts.AsNoTracking().AsQueryable();

        if (!string.IsNullOrWhiteSpace(f.Text))
        {
            var t = f.Text.Trim();
            q = q.Where(d =>
                EF.Functions.ILike(d.DisplayName, $"%{t}%") ||
                (d.DiscountCode != null && EF.Functions.ILike(d.DiscountCode, $"%{t}%")));
        }
        if (!string.IsNullOrWhiteSpace(f.ParentOrgId))
            q = q.Where(d => d.ParentOrgId == f.ParentOrgId);

        if (f.IsEnabled.HasValue)
            q = q.Where(d => d.IsEnabled == f.IsEnabled);

        if (f.ActiveNow.HasValue)
        {
            var now = DateTime.UtcNow;
            q = f.ActiveNow.Value
                ? q.Where(d => d.IsEnabled &&
                               (!d.StartsAtUtc.HasValue || d.StartsAtUtc <= now) &&
                               (!d.EndsAtUtc.HasValue   || d.EndsAtUtc   >= now))
                : q.Where(d => !d.IsEnabled ||
                               (d.StartsAtUtc.HasValue && d.StartsAtUtc >  now) ||
                               (d.EndsAtUtc.HasValue   && d.EndsAtUtc   <  now));
        }

        if (f.Type.HasValue) q = q.Where(d => d.Type == f.Type);
        if (f.ScopeEquals.HasValue) q = q.Where(d => d.Scope == f.ScopeEquals);

        if (f.ScopeMinInclusive.HasValue) q = q.Where(d => (int)d.Scope >= f.ScopeMinInclusive.Value);
        if (f.ScopeMaxInclusive.HasValue) q = q.Where(d => (int)d.Scope <= f.ScopeMaxInclusive.Value);

        if (f.StartsBeforeUtc.HasValue) q = q.Where(d => !d.StartsAtUtc.HasValue || d.StartsAtUtc <= f.StartsBeforeUtc.Value);
        if (f.EndsAfterUtc.HasValue)   q = q.Where(d => !d.EndsAtUtc.HasValue   || d.EndsAtUtc   >= f.EndsAfterUtc.Value);

        var skip = Math.Max(0, f.Skip ?? 0);
        var take = Math.Clamp(f.Take ?? 50, 1, 500);

        return await q
            .OrderBy(d => d.DisplayName).ThenBy(d => d.Id)
            .Skip(skip).Take(take)
            .ToListAsync(ct);
    }

    public async Task<IReadOnlyList<IBillingService.DiscountPickerDto>> GetDiscountsForPickerAsync(IBillingService.DiscountSearchParams f, CancellationToken ct = default)
    {
        var list = await SearchDiscountsAsync(f with { Skip = 0, Take = 200 }, ct);
        return list.Select(d => new IBillingService.DiscountPickerDto
        {
            Id          = d.Id,
            Name        = d.DisplayName,
            Code        = d.DiscountCode,
            Type        = d.Type,
            Amount      = d.Amount,
            Scope       = d.Scope,
            IsEnabled   = d.IsEnabled,
            IsActive    = d.IsActive,
            Currency    = d.Currency,
            StartsAtUtc = d.StartsAtUtc,
            EndsAtUtc   = d.EndsAtUtc
        }).ToList();
    }


    // ------------------ UPDATE ---------------------
    public async Task<bool> UpdateDiscountAsync(Discount replacement, CancellationToken ct = default)
    {
        if (replacement is null) throw new ArgumentNullException(nameof(replacement));
        replacement.DisplayName = replacement.DisplayName?.Trim() ?? string.Empty;
        if (replacement.DiscountCode is null) throw new ArgumentException("DiscountCode is required.", nameof(replacement.DiscountCode));
        replacement.DiscountCode = NormalizeCode(replacement.DiscountCode);
        replacement.Currency = replacement.Currency is null ? null : replacement.Currency.Trim().ToUpperInvariant();
        replacement.Amount = DecimalNormalize(replacement.Amount);

        replacement.Validate();

        _db.ChangeTracker.Clear();

        _db.Attach(replacement);
        var e = _db.Entry(replacement);

        e.State = EntityState.Unchanged;
        foreach (var p in e.Properties)
        {
            if (p.Metadata.IsKey()) continue;
            if (p.Metadata.IsConcurrencyToken) continue;
            p.IsModified = true; // scalars only
        }

        var affected = await _db.SaveChangesAsync(ct);
        return affected > 0;
    }

    public async Task<bool> UpdateDiscountFieldAsync<T>(
        string id,
        Expression<Func<Discount, T>> property,
        T value,
        CancellationToken ct = default)
    {
        var member = property.Body as MemberExpression
                    ?? throw new ArgumentException("Property expression must be a simple member access.", nameof(property));
        var propName = member.Member.Name;

        var affected = await _db.Discounts
            .Where(d => d.Id == id)
            .ExecuteUpdateAsync(
                setters => setters.SetProperty(
                    d => EF.Property<T>(d, propName),   // <- Expression<Func<Discount,T>>
                    value                               // constant value
                ),
                ct);

        return affected > 0;
    }

    public Task<bool> SetDiscountEnabledAsync(string id, bool enabled, CancellationToken ct = default)
        => UpdateDiscountFieldAsync(id, d => d.IsEnabled, enabled, ct);


    // ----------------- DELETE ----------------------

    public async Task<bool> DeleteDiscountAsync(string id, CancellationToken ct = default)
    {
        var d = await _db.Discounts.FirstOrDefaultAsync(x => x.Id == id, ct);
        if (d is null) return false;
        _db.Discounts.Remove(d);
        await _db.SaveChangesAsync(ct);
        return true;
    }


    // ----------------- Helpers ---------------------

    private static string NormalizeCode(string code)
        => new string(code.Trim().ToUpperInvariant().Where(char.IsLetterOrDigit).ToArray());

    private static decimal DecimalNormalize(decimal value)
        => decimal.Round(value, 4, MidpointRounding.AwayFromZero);

    private static void GuardCreate(IBillingService.CreateDiscountRequest req)
    {
        if (string.IsNullOrWhiteSpace(req.DisplayName))
            throw new ArgumentException("DisplayName is required.", nameof(req.DisplayName));

        if (req.Type == DiscountType.Percentage)
        {
            if (req.Amount < 0m || req.Amount > 100m)
                throw new ArgumentOutOfRangeException(nameof(req.Amount), "Percentage must be 0â€“100.");
            if (!string.IsNullOrWhiteSpace(req.Currency))
                throw new ArgumentException("Currency must be null for percentage discounts.", nameof(req.Currency));
        }
        else
        {
            if (req.Amount < 0m)
                throw new ArgumentOutOfRangeException(nameof(req.Amount), "Fixed amount cannot be negative.");
            if (string.IsNullOrWhiteSpace(req.Currency) || req.Currency!.Trim().Length != 3)
                throw new ArgumentException("Currency (ISO-4217) is required for fixed-amount discounts.", nameof(req.Currency));
        }

        if (req.SeatMin.HasValue && req.SeatMin < 0) throw new ArgumentOutOfRangeException(nameof(req.SeatMin));
        if (req.SeatMax.HasValue && req.SeatMax < 0) throw new ArgumentOutOfRangeException(nameof(req.SeatMax));
        if (req.SeatMin.HasValue && req.SeatMax.HasValue && req.SeatMin > req.SeatMax)
            throw new ArgumentException("SeatMin cannot exceed SeatMax.");

        if (req.StartsAtUtc.HasValue && req.EndsAtUtc.HasValue && req.EndsAtUtc < req.StartsAtUtc)
            throw new ArgumentException("EndsAtUtc cannot be earlier than StartsAtUtc.");
    }

    private static class CodeGen
    {
        // Example: DS-202510-AB12CD34
        public static string NewDiscountCode()
        {
            var yyyymm = DateTime.UtcNow.ToString("yyyyMM");
            var rand = Nanoid.Generate(size: 8).ToUpperInvariant();
            return $"DS-{yyyymm}-{rand}";
        }
    }
}
